软件解决方案的问题

1. 虚拟机和RTOS对全局环境的共享，这种情况并不会用半虚拟化机制（无地址访问权限而陷入仿真）就可以解决，因为同一level，总会覆盖
如果partition驻留RTOS，且与hypervisor在同一level，
那么RTOS的内核级配置就显得意义不大，因为会覆盖hypervisor，
并且多种RTOS的内核配置可能有差异
2. code/data/设备间地址空间的划分，既要严格限制范围，又要考虑MPU的region数量，因为碎片化的划分会导致region不够使用
3. 多个调度器而引入的冲突，对于虚拟机来说是分区调度器，而每一个分区都有自己的任务调度器，从逻辑上讲，应该是分区调度器优先级 > 任务调度器，
分区调度器仅在时间片到达时才会作用，任务调度器仅在分区进入时才开始作用（这个限制需要遵循）
4. 分区和虚拟机异常向量共享，这时由虚拟机接管多个RTOS的异常，这里就包括调度，所以RTOS的调度器也是受虚拟机接管的
并且设备驱动也必须驻留在虚拟机，同样也是由于异常向量表（设备）也是由虚拟机接管

以下异常向量句柄需要让虚拟机和RTOS兼容： 以cortex-M - RTOS为例
1. vPortSVCHandler（这个是不是可以删除，例如禁止RTOS使用svc）
2. xPortPendSVHandler（它的调用是在虚拟机任务切换时切换到自己时使用，也就是当前任务在任务切换过程中仍是自己时）
3. xPortSysTickHandler（可以不用，大家用法都相似，大抵是设置pendsv中断使能）
禁止RTOS设置系统寄存器



还有一种方案是动态的修改中断向量表基地址，由每一个分区定期主动放弃CPU所有权，在这种情况下，虚拟机先设置一致的静态全局环境（主要是一些基本的系统寄存器），
然后，在任务切换时动态修改中断向量表的基地址。

干脆就是让每一个分区的所有任务都当成虚拟机的任务，只不过这些任务是一个分组（RTOS），这样RTOS的调度上下文底层由虚拟机代替。
所有RTOS的中断向量表由虚拟机代替。或是说，所有分区的任务只是线程，而分区是进程而已

如果定义一个异构内核互通协议呢？包括在同一个level下的互通翻译协议
如果真有这种协议的话，实现该协议的内核都有相当强的扩展能力。
例如，该内核可以支持posix支持的扩展，满足用户的需求，同时代码量少，易于扩展到其他领域内
以一个module的形式驻留在多个soc上，以统一的资源面来弥补不同用户的差异；并且在支持该协议后，可以做到轻量级的切换到另一个内核，执行一些
该内核没法单独实现的功能，并且还可以从另一个内核返回，继续执行当前任务；比实现的host-guest更为轻量
这个协议其实比硬件实现的虚拟化机制更为轻

上下文翻译协议可以作为资源协议的一类，之前可能把资源协议作为统筹不同用户的手段，这点还是局限的
这点不可否认，与容器的概念类似

比如当切换到某个内核的任务上下文时，翻译到该内核任务的环境；切换到另一个内核的任务上下文时，也是如此
1. 上下文翻译协议（局部环境翻译，全局环境还是最好唯一，由虚拟机决定（这个还是以major为好，其他的称为minor））
1.1 可以在RTOS镜像处定义一个头部数据，由虚拟机获知（包括镜像入口地址，当前任务/栈帧，任务切换函数resched）

partition ops
1. 创建，删除，休眠，唤醒，重启