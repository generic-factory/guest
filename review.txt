
突出观点
1. 逻辑核（上下文环境切换）与物理核（环境初始化）
2. 执行实体与入口点，入口点以handler称谓，例如异常handler是内核执行实体的入口点，
start是各个镜像（一般镜像以用户线程或内核的形式存在）自身的入口点，
每一个入口点都需要设置或保存恢复环境或上下文。
还有很多其他的handler，例如signal（用户）/thread/process（用户和内核） handler
是每个线程的入口点，以及exp/irq handler是内核的入口点
3. 栈和上下文区，对于每一个用户线程而言，必须有用户栈和上下文区，因为用户函数需要栈，
用户会陷入内核或是切换到其他用户线程，所以需要上下文区保存和恢复上下文；
当陷入内核执行内核函数时，必须需要内核栈，因为内核允许并发时，
同一个内核函数需要同时被多个用户线程访问；同时也需要上下文区，
因为在执行内核函数时，可能会切换到其他用户线程或是异常handler。
对于内核线程来说，需要内核栈和上下文区。对于内核其他句柄来说，
包括中断和异常句柄，需要共用内核配置好（包括内核初始化的流程）
的percpu栈，至于是否需要上下文区待定，因为根据pcs，在函数嵌套调用时
也会保存一部分环境，说白了每一个handler都需要栈。
所以，设置上下文区的条件是执行实体的切换。
例如，从用户线程和用户线程切换，需要被切换方用户线程保存上下文；
用户线程切换内核（内核线程或内核异常），需要用户线程保存上下文；
内核线程切换用户线程，需要内核线程保存上下文；内核同步异常切换用户线程，
需要用户内核上下文区保存上下文；内核异步异常切换用户，一定是执行完成，
不可中途打断，所以不需上下文区；内核线程或切换内核线程，需要被切换方内核线程保存上下文；
内核同步异常（优先级低）切换异常（优先级高），需要用户内核上下文区保存上下文；
内核异步异常（优先级低，中断）切换异步异常（优先级高）一定不会是内核同步异常，
属于嵌套调用，不需要上下文区，保证栈足够即可，因为顶层执行实体不需要上下文区，
因为它们不会切走；但实际上内核异步异常发生后，是不能嵌套调用，非常容易无限循环调用，因为出现的
异常在没有解决时，会一直异步进入该异常，所以一旦可以返回，就会出现死循环

- 可重入：该handler可以在任意时刻被打断，后面会从这个打断点恢复，很明显具备上下文的handler是可重入的
- 不可重入：该handler不能被打断，必须从头执行到尾，或是只能执行一次，不能返回（内核异步异常）

4. handler的可迁移性，指的是一个用户线程handler是否可以在另一个用户线程handler使用，
首先需要对该handler所在的代码段可访问，为该handler分配新的栈不是必要的，因为栈桢是链式的，
可以追溯到的，该handler执行的上下文为当前线程所有，
唯一的问题是该handler以及所依赖的所有handler的代码段均可以被另一个线程可访问。
所以，如果内核是被所有用户线程可访问，那么完全将一部分内核管理函数放置在用户态，
且将这部分函数作为共享库，被多个用户共享使用，这样降低了内核故障的风险，并将其转移到用户态。
回到原本的问题，一个用户线程handler与另一个线程handler互访问，答案是可以的，
只要这部分代码作为共享库，私有的handler是不可以的
5. 上下文的设置还需要看该handler的生命周期，如果该handler从头执行到尾，中间不会被打断，
这种是不需要上下文的。只有那种可能被打断的handler才需要上下文来恢复上次被打断的位置。
还有上下文和栈的区别就是组合和嵌套式handler的区别。上下文设置为了组合调用，栈是为了嵌套调用，
所以各式的切换必须以上下文的方式来保存和恢复，而中断或异常嵌套调用仅用栈就可以保存和恢复

